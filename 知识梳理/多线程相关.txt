保证可见性的方法？
volatile
synchronized （unlock之前，写变量值回主存）
final(一旦初始化完成，其他线程就可见)

指令重排的基本原则？(Happen-Before原则)
程序顺序原则：一个线程内保证语义的串行性
volatile规则：volatile变量的写，先发生于读
锁规则：解锁(unlock)必然发生在随后的加锁(lock)前
传递性：A先于B，B先于C 那么A必然先于C
线程的start方法先于它的每一个动作
线程的所有操作先于线程的终结（Thread.join()）
线程的中断（interrupt()）先于被中断线程的代码
对象的构造函数执行结束先于finalize()方法

原子类：
CAS？
AtomicInteger？AtomicReference？AtomicStampedReference？AtomicIntegerArray？AtomicReferenceArray？
AtomicIntegerFieldUpdater? 让普通变量也享受原子操作，AtomicIntegerFieldUpdater.new Updater(*.class,"field")反射？？